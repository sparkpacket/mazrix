<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mazrix</title>
  <style>
    html,body {
      margin: 0;
      background: #000;
      height: 100%;
      overflow: hidden;
    }

    /* Grid */
    #grid {
      display: grid;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* helps pointer events on mobile */
    }
    .cell {
      box-sizing: border-box;
      width: 100%;
      height: 100%;
    }
    .wall { background: #000; }
    .air { background: #fff; }
    .start { background: green; }
    .end { background: red; }
    .player { background: blue; }
    .hidden { background: #000 !important; }

    /* D-pad (bottom-left) */
    #dpad {
      position: fixed;
      left: 14px;
      bottom: 14px;
      display: grid;
      grid-template-columns: 56px 56px 56px;
      grid-template-rows: 56px 56px 56px;
      gap: 8px;
      width: calc(56px * 3 + 16px);
      height: calc(56px * 3 + 16px);
      z-index: 9999;
      user-select: none;
      -webkit-user-select: none;
    }
    .d-btn {
      width: 56px;
      height: 56px;
      border-radius: 12px;
      border: none;
      font-size: 20px;
      background: rgba(100,100,100,0.55);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
    .d-btn:active { transform: scale(0.96); }

    /* Action buttons (bottom-right) */
    #actions {
      position: fixed;
      right: 16px;
      bottom: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 9999;
      user-select: none;
    }
    .act-btn {
      width: 72px;
      height: 72px;
      border-radius: 999px;
      border: none;
      background: rgba(0,120,255,0.55);
      color: #fff;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
    .act-btn:active { transform: scale(0.97); }

    /* Hide controls by default; shown via JS on mobile */
    .hidden-controls { display: none; }

    /* Make buttons slightly smaller on very small screens */
    @media (max-width: 360px) {
      #dpad { transform: scale(0.9); transform-origin: left bottom; }
      #actions { transform: scale(0.9); transform-origin: right bottom; }
    }
  </style>
</head>
<body>

<div id="grid"></div>

<!-- D-pad (3x3 placeholders, arrows in cardinal places) -->
<div id="dpad" class="hidden-controls" aria-hidden="true">
  <div></div>
  <button id="upBtn" class="d-btn" aria-label="Up">▲</button>
  <div></div>

  <button id="leftBtn" class="d-btn" aria-label="Left">◀</button>
  <div></div>
  <button id="rightBtn" class="d-btn" aria-label="Right">▶</button>

  <div></div>
  <button id="downBtn" class="d-btn" aria-label="Down">▼</button>
  <div></div>
</div>

<!-- Action buttons -->
<div id="actions" class="hidden-controls" aria-hidden="true">
  <button id="flashlightBtn" class="act-btn" aria-label="Toggle flashlight">Light</button>
  <button id="playBtn" class="act-btn" aria-label="Start or stop">Play</button>
</div>

<script>
  const gridElement = document.getElementById('grid');
  let gridSize = 30;
  let cells = [];
  let players = [];
  let playing = false;
  let flashlightMode = 0; // 0: fullbright, 1: darkness, 2: flashlight
  const flashlightRadius = 5;

  function createGrid(size) {
    gridSize = size;
    gridElement.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
    gridElement.style.gridTemplateRows = `repeat(${size}, 1fr)`;
    gridElement.innerHTML = '';
    cells = [];
    for (let y = 0; y < size; y++) {
      const row = [];
      for (let x = 0; x < size; x++) {
        const cell = document.createElement('div');
        cell.classList.add('cell', 'wall');
        cell.dataset.state = 'wall';
        cell.dataset.x = x;
        cell.dataset.y = y;

        // Use pointerdown for both mouse and touch: more reliable on mobile
        cell.addEventListener('pointerdown', ev => {
          // only handle primary button for mouse
          if (ev.pointerType === 'mouse' && ev.button !== 0) return;
          cycleTile(cell);
        });

        gridElement.appendChild(cell);
        row.push(cell);
      }
      cells.push(row);
    }
  }

  function cycleTile(cell) {
    const state = cell.dataset.state;
    cell.classList.remove(state);
    if (state === 'wall') {
      cell.dataset.state = 'air';
    } else if (state === 'air') {
      cell.dataset.state = 'start';
    } else if (state === 'start') {
      cell.dataset.state = 'end';
    } else {
      cell.dataset.state = 'wall';
    }
    cell.classList.add(cell.dataset.state);
  }

  function startGame() {
    players = [];
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const cell = cells[y][x];
        if (cell.dataset.state === 'start') {
          players.push({x, y});
        }
        cell.classList.remove('player');
      }
    }
    if (players.length === 0) {
      alert("No start tile!");
      return;
    }
    playing = true;
    updatePlayerVisuals();
    updateLighting();
    updatePlayButton();
  }

  function stopGame() {
    playing = false;
    updatePlayButton();
  }

  function updatePlayButton() {
    const playBtn = document.getElementById('playBtn');
    if (!playBtn) return;
    playBtn.textContent = playing ? 'Stop' : 'Play';
  }

  function updateLightButton() {
    const b = document.getElementById('flashlightBtn');
    if (!b) return;
    const labels = ['Full', 'Dark', 'Flash'];
    b.textContent = `Light: ${labels[flashlightMode]}`;
  }

  function updatePlayerVisuals() {
    for (let row of cells) for (let cell of row) cell.classList.remove('player');
    for (let p of players) cells[p.y][p.x].classList.add('player');
  }

  function movePlayers(dx, dy) {
    if (!playing) return;
    players = players.map(p => {
      const nx = p.x + dx;
      const ny = p.y + dy;
      if (nx >= 0 && ny >= 0 && nx < gridSize && ny < gridSize) {
        const next = cells[ny][nx];
        if (next.dataset.state !== 'wall' && !players.some(o => o.x === nx && o.y === ny)) {
          return {x: nx, y: ny};
        }
      }
      return p;
    });
    updatePlayerVisuals();
    updateLighting();
    checkWin();
  }

  function checkWin() {
    const allAtEnd = players.length > 0 && players.every(p => cells[p.y][p.x].dataset.state === 'end');
    if (allAtEnd) {
      alert("You win!");
      stopGame();
    }
  }

  function updateLighting() {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const cell = cells[y][x];
        cell.classList.remove('hidden');
      }
    }

    if (flashlightMode === 0) return; // Fullbright

    if (flashlightMode === 1) {
      for (let row of cells) {
        for (let cell of row) {
          if (cell.dataset.state === 'air') cell.classList.add('hidden');
        }
      }
      return;
    }

    // Mode 2: flashlight around players
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        let visible = false;
        for (let p of players) {
          const dx = x - p.x;
          const dy = y - p.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist <= flashlightRadius && cells[y][x].dataset.state === 'air') {
            visible = true;
            break;
          }
        }
        if (!visible) cells[y][x].classList.add('hidden');
      }
    }
  }

  // keyboard support retained
  document.addEventListener('keydown', e => {
    if (e.key === 'Tab') { e.preventDefault(); playing ? stopGame() : startGame(); }
    if (e.key === 'ArrowUp') movePlayers(0, -1);
    if (e.key === 'ArrowDown') movePlayers(0, 1);
    if (e.key === 'ArrowLeft') movePlayers(-1, 0);
    if (e.key === 'ArrowRight') movePlayers(1, 0);
    if (e.key.toLowerCase && e.key.toLowerCase() === 'f') {
      flashlightMode = (flashlightMode + 1) % 3;
      updateLighting();
      updateLightButton();
    }
  });

  // mobile detection: prefer touch capability or coarse pointer
  function isMobileLike() {
    return (('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
            window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
  }

  // Hook up D-pad and action buttons with hold-to-repeat support
  function addHoldButton(elem, onClick, repeatDelay = 220, repeatInterval = 110) {
    if (!elem) return;
    let interval = null;
    let timeout = null;

    const start = (ev) => {
      ev.preventDefault();
      onClick();
      // start repeating after delay
      timeout = setTimeout(() => {
        interval = setInterval(onClick, repeatInterval);
      }, repeatDelay);
    };
    const stop = () => {
      if (timeout) { clearTimeout(timeout); timeout = null; }
      if (interval) { clearInterval(interval); interval = null; }
    };

    elem.addEventListener('pointerdown', start);
    // pointerup/pointercancel on window so release outside button still stops it
    window.addEventListener('pointerup', stop);
    window.addEventListener('pointercancel', stop);
    // also support mouse leaving
    elem.addEventListener('mouseleave', stop);
    // single tap fallback handled since start() calls onClick immediately
  }

  // Wire up movement and action buttons if present
  function setupControls() {
    const up = document.getElementById('upBtn');
    const down = document.getElementById('downBtn');
    const left = document.getElementById('leftBtn');
    const right = document.getElementById('rightBtn');
    const flash = document.getElementById('flashlightBtn');
    const play = document.getElementById('playBtn');

    addHoldButton(up, () => movePlayers(0, -1));
    addHoldButton(down, () => movePlayers(0, 1));
    addHoldButton(left, () => movePlayers(-1, 0));
    addHoldButton(right, () => movePlayers(1, 0));

    if (flash) {
      flash.addEventListener('pointerdown', ev => {
        ev.preventDefault();
        flashlightMode = (flashlightMode + 1) % 3;
        updateLighting();
        updateLightButton();
      });
    }

    if (play) {
      play.addEventListener('pointerdown', ev => {
        ev.preventDefault();
        if (playing) stopGame(); else startGame();
      });
    }
  }

  // Show/hide controls based on device type
  function showMobileControlsIfNeeded() {
    const show = isMobileLike();
    const dpad = document.getElementById('dpad');
    const actions = document.getElementById('actions');
    if (show) {
      dpad.classList.remove('hidden-controls');
      actions.classList.remove('hidden-controls');
    } else {
      dpad.classList.add('hidden-controls');
      actions.classList.add('hidden-controls');
    }
  }

  // init
  createGrid(gridSize);
  showMobileControlsIfNeeded();
  setupControls();
  updateLightButton();
  updatePlayButton();
</script>

</body>
</html>
